activeTab: 'model',
activeHistoryFilter: 'all',
activeProfile: 'browser',
serverConfig: {},

// DATA HOLDERS
configs: { browser: {}, twilio: {}, telnyx: {} },

// CATALAGS
voices: [],
styles: [],
models: [],
languages: [],

// UI COMPUTED LISTS
availableModels: [],
availableLanguages: [],
availableVoices: [],
availableStyles: [],
availableGenders: [],
currentGender: 'female',
isPreviewLoading: false,

// CURRENT CONFIG POINTER (Convenience accessor for UI binding)
get c() { return this.configs[this.activeProfile]; },

async init() {
// 1. SAFELY PARSE SERVER DATA
try {
this.serverConfig = JSON.parse(document.getElementById('server-config').textContent);
this.voices = JSON.parse(document.getElementById('server-voices').textContent);
this.styles = JSON.parse(document.getElementById('server-styles').textContent);
this.models = JSON.parse(document.getElementById('server-models').textContent);
this.languages = JSON.parse(document.getElementById('server-langs').textContent);
} catch (e) {
console.error("CRITICAL: JSON Parsing failed", e);
return; // Stop execution if critical data missing
}

// 1.1 RESTORE TAB STATE
const urlParams = new URLSearchParams(window.location.search);
const requestedTab = urlParams.get('tab');
if (requestedTab) {
this.activeTab = requestedTab.toLowerCase();
}

// 2. INITIALIZE CONFIG STORE FROM SERVER DATA
this.initBrowserConfig();
this.initTwilioConfig();
this.initTelnyxConfig();

// 3. SETUP WATCHERS & INITIAL UI LISTS
this.$watch('activeProfile', () => this.refreshUI());

// Watch provider changes AFTER init - user changing provider should update models
this.$watch('c.provider', (newVal, oldVal) => {
// Only call if value actually changed (not during init)
if (oldVal !== undefined && newVal !== oldVal) {
this.updateModelList();
}
});

// refreshUI() will call updateModelList() at the correct time
this.refreshUI();
},

initBrowserConfig() {
const s = this.serverConfig;
this.configs.browser = {
provider: s.llm_provider || 'groq',
model: s.llm_model || '',
temp: s.temperature || 0.7,
tokens: s.max_tokens || 250,
msg: s.first_message || '',
mode: s.first_message_mode || 'speak-first',
prompt: s.system_prompt || '',

// NEW: Conversation Style Controls
responseLength: s.response_length || 'short',
conversationTone: s.conversation_tone || 'warm',
conversationFormality: s.conversation_formality || 'semi_formal',
conversationPacing: s.conversation_pacing || 'moderate',

voiceProvider: s.tts_provider || 'azure',
voiceLang: s.voice_language || 'es-MX',
voiceId: s.voice_name || '',
voiceStyle: s.voice_style || '',
voiceSpeed: s.voice_speed || 1.0,
voicePitch: s.voice_pitch || 0,
voiceVolume: s.voice_volume || 100,
voiceStyleDegree: s.voice_style_degree || 1.0,
voicePacing: s.voice_pacing_ms || 0,
voiceBgSound: s.background_sound || 'none',
voiceBgUrl: s.background_sound_url || '',

sttProvider: s.stt_provider || 'azure',
sttLang: s.stt_language || 'es-MX',
interruptWords: s.interruption_threshold || 0,
silence: s.silence_timeout_ms || 5000,
blacklist: s.hallucination_blacklist || '',

enableEndCall: s.enable_end_call,
dialKeypad: s.enable_dial_keypad,
transferNum: s.transfer_phone_number,

idleTimeout: s.idle_timeout || 10,
maxDuration: s.max_duration || 600,
idleMessage: s.idle_message || '',
maxRetries: s.inactivity_max_retries || 3,
denoise: s.enable_denoising || false,
extractionModel: s.extraction_model || 'llama-3.1-8b-instant',

// CRM & Webhook (Global but editing in browser profile for convenience)
crm_enabled: s.crm_enabled || false,
baserow_token: s.baserow_token || '',
baserow_table_id: s.baserow_table_id || '',
webhook_url: s.webhook_url || '',
webhook_secret: s.webhook_secret || ''
};
},

initTwilioConfig() {
const s = this.serverConfig;
this.configs.twilio = {
provider: s.llm_provider_phone || s.llm_provider || 'groq',
model: s.llm_model_phone || s.llm_model || '',
temp: s.temperature_phone || s.temperature || 0.7,
tokens: s.max_tokens_phone || s.max_tokens || 250,
msg: s.first_message_phone || s.first_message || '',
mode: s.first_message_mode_phone || s.first_message_mode || 'speak-first',
prompt: s.system_prompt_phone || '',

voiceProvider: s.tts_provider_phone || s.tts_provider || 'azure',
voiceLang: s.voice_language_phone || 'es-MX',
voiceId: s.voice_name_phone || '',
voiceStyle: s.voice_style_phone || '',
voiceSpeed: s.voice_speed_phone || 1.0,
voicePitch: s.voice_pitch_phone || 0,
voiceVolume: s.voice_volume_phone || 100,
voiceStyleDegree: s.voice_style_degree_phone || 1.0,
voicePacing: s.voice_pacing_ms_phone || 0,
voiceBgSound: s.background_sound_phone || 'none',

sttProvider: s.stt_provider_phone || 'azure',
sttLang: s.stt_language_phone || 'es-MX',
interruptWords: s.interruption_threshold_phone || 0,
silence: s.silence_timeout_ms_phone || 5000,
inputMin: s.input_min_characters_phone || 0,
blacklist: s.hallucination_blacklist_phone || '',
denoise: s.enable_denoising_phone || false,

// Aliases for global fields to prevent UI errors if user switches tab
crm_enabled: s.crm_enabled || false,
baserow_token: s.baserow_token || '',
baserow_table_id: s.baserow_table_id || '',
webhook_url: s.webhook_url || '',
webhook_secret: s.webhook_secret || ''
};
},

initTelnyxConfig() {
const s = this.serverConfig;
this.configs.telnyx = {
provider: s.llm_provider_telnyx || s.llm_provider || 'groq',
model: s.llm_model_telnyx || s.llm_model || '',
temp: s.temperature_telnyx || s.temperature || 0.7,
tokens: s.max_tokens_telnyx || s.max_tokens || 250,
msg: s.first_message_telnyx || s.first_message || '',
mode: s.first_message_mode_telnyx || s.first_message_mode || 'speak-first',
prompt: s.system_prompt_telnyx || '',

voiceProvider: s.tts_provider_telnyx || s.tts_provider || 'azure',
voiceLang: s.voice_language_telnyx || 'es-MX',
voiceId: s.voice_name_telnyx || '',
voiceStyle: s.voice_style_telnyx || '',
voiceSpeed: s.voice_speed_telnyx || 1.0,
voicePitch: s.voice_pitch_telnyx || 0,
voiceVolume: s.voice_volume_telnyx || 100,
voiceStyleDegree: s.voice_style_degree_telnyx || 1.0,
voicePacing: s.voice_pacing_ms_telnyx || 0,
voiceBgSound: s.background_sound_telnyx || 'none',
voiceBgUrl: s.background_sound_url_telnyx || '',

sttProvider: s.stt_provider_telnyx || 'azure',
sttLang: s.stt_language_telnyx || 'es-MX',
interruptWords: s.interruption_threshold_telnyx || 0,
interruptRMS: s.voice_sensitivity_telnyx || 0,
silence: s.silence_timeout_ms_telnyx || 5000,
inputMin: s.input_min_characters_telnyx || 0,
blacklist: s.hallucination_blacklist_telnyx || '',
denoise: s.enable_denoising_telnyx || false,
krisp: s.enable_krisp_telnyx || false,
vad: s.enable_vad_telnyx || false,

idleTimeout: s.idle_timeout_telnyx || 20,
maxDuration: s.max_duration_telnyx || 600,
idleMessage: s.idle_message_telnyx || '',
enableRecording: s.enable_recording_telnyx || false,
amdConfig: s.amd_config_telnyx || 'disabled',

// Aliases for global fields
crm_enabled: s.crm_enabled || false,
baserow_token: s.baserow_token || '',
baserow_table_id: s.baserow_table_id || '',
webhook_url: s.webhook_url || '',
webhook_secret: s.webhook_secret || ''
};
},

ensureModelExists(provider, modelId) {
if (!provider || !modelId) return;
const p = provider.trim().toLowerCase();
const m = modelId.trim();

if (!this.models[p]) this.models[p] = [];

const exists = this.models[p].find(x => x.id === m);
if (!exists) {
console.log(`ðŸ”§ [DATA-FIX] Injecting missing model '${m}' into provider '${p}'`);
this.models[p].unshift({ id: m, name: m + ' (Saved)' });
}
},

sanitizeAllProfiles() {
// Pre-scan all profiles and ensure their saved models exist in the catalog
const s = this.serverConfig || {};

// Browser
this.ensureModelExists(s.llm_provider, s.llm_model);
// Twilio
this.ensureModelExists(s.llm_provider_phone, s.llm_model_phone);
// Telnyx
this.ensureModelExists(s.llm_provider_telnyx, s.llm_model_telnyx);
},

refreshUI() {
// 1. Sanitize Data Source first
this.sanitizeAllProfiles();

// 2. Update computed lists
this.updateModelList();
this.updateVoiceLists();
},

updateModelList() {
// Get CURRENT provider from UI (what user selected NOW)
const currentProvider = (this.c.provider || 'groq').trim().toLowerCase();

// Update available models list based on CURRENT provider selection
this.availableModels = this.models[currentProvider] || [];

// Get saved model from server for persistence
const s = this.serverConfig || {};
let savedModel = '';

if (this.activeProfile === 'browser') {
savedModel = s.llm_model;
} else if (this.activeProfile === 'twilio') {
savedModel = s.llm_model_phone;
} else if (this.activeProfile === 'telnyx') {
savedModel = s.llm_model_telnyx;
}

// Use $nextTick to wait for <option> elements to render
    this.$nextTick(() => {
    // Check if current model is valid for new provider
    const currentModelValid = this.availableModels.find(m => m.id === this.c.model);

    if (savedModel && this.availableModels.find(m => m.id === savedModel)) {
    // Saved model exists in available models - use it
    this.c.model = '';
    this.$nextTick(() => {
    this.c.model = savedModel;
    });
    } else if (!currentModelValid && this.availableModels.length > 0) {
    // Current model invalid for new provider - select first available
    this.c.model = this.availableModels[0].id;
    }
    // If currentModelValid, keep current selection (user might be switching back)
    });
    },

    updateVoiceLists() {
    // Get CURRENT provider and language from UI (what user selected NOW)
    let prov = (this.c.voiceProvider || 'azure').trim().toLowerCase();
    this.availableLanguages = this.languages[prov] || [];

    // Validate Lang
    if (!this.availableLanguages.find(l => l.id === this.c.voiceLang)) {
    this.c.voiceLang = this.availableLanguages[0]?.id || '';
    }

    // Get Voices for CURRENT Prov + Lang
    let allVoices = (this.voices[prov] || {})[this.c.voiceLang] || [];

    // Extract Genders
    let gendersSet = new Set(allVoices.map(v => v.gender));
    this.availableGenders = Array.from(gendersSet).map(g => ({
    id: g,
    name: g === 'female' ? 'Femenino' : (g === 'male' ? 'Masculino' : 'Neutral')
    }));

    // Ensure Gender Selection
    if (!gendersSet.has(this.currentGender) && this.availableGenders.length > 0) {
    this.currentGender = this.availableGenders[0].id; // Fallback
    }

    // Filter by Gender
    let tmpVoices = allVoices.filter(v => v.gender === this.currentGender);

    // Get saved voice for persistence
    const s = this.serverConfig || {};
    let savedVoiceId = '';

    if (this.activeProfile === 'browser') {
    savedVoiceId = s.voice_name;
    } else if (this.activeProfile === 'twilio') {
    savedVoiceId = s.voice_name_phone;
    } else if (this.activeProfile === 'telnyx') {
    savedVoiceId = s.voice_name_telnyx;
    }

    // Set available voices
    this.availableVoices = tmpVoices;

    // Restore saved voice with $nextTick for DOM timing
    this.$nextTick(() => {
    // Check if saved voice exists in current available voices
    const voiceExists = savedVoiceId && this.availableVoices.find(v => v.id === savedVoiceId);

    if (voiceExists) {
    // Saved voice is valid for current selection - restore it
    this.c.voiceId = '';
    this.$nextTick(() => {
    console.log("ðŸ”’ [PERSISTENCE] Restoring saved voice:", savedVoiceId);
    this.c.voiceId = savedVoiceId;
    });
    } else if (this.availableVoices.length > 0) {
    // Saved voice not valid - select first available
    const currentValid = this.availableVoices.find(v => v.id === this.c.voiceId);
    if (!currentValid) {
    console.log("ðŸ”„ [AUTO-SELECT] Selecting first available voice");
    this.c.voiceId = this.availableVoices[0].id;
    }
    }
    });

    this.updateStyleList();
    },

    // Watcher for UI Preferences
    setVisualizer(mode) {
    this.visualizerMode = mode;
    localStorage.setItem('sim_visualizerMode', mode);
    },

    updateStyleList() {
    let vid = this.c.voiceId;
    let rawStyles = this.styles[vid] || this.styles['default'] || [];

    // Normalize strings to objects for UI template (which expects s.id and s.label)
    this.availableStyles = rawStyles.map(s => {
    if (typeof s === 'string') return { id: s, label: s.charAt(0).toUpperCase() + s.slice(1) };
    return s;
    });

    // Validate Style
    if (this.c.voiceStyle && !this.availableStyles.find(s => s.id === this.c.voiceStyle)) {
    this.c.voiceStyle = ''; // Reset to default if current style not valid for this voice
    }
    },

    setGender(g) {
    this.currentGender = g;
    this.updateVoiceLists();
    },

    shouldShowTab(t) {
    if (t === 'ConexiÃ³n' && this.activeProfile === 'browser') return false;
    return true;
    },